# {{ .ChartName }}

{{ .Description | default "A production-ready Helm chart for Kubernetes deployment" }}

## Overview

This Helm chart deploys {{ .AppName | default .ChartName }} on a Kubernetes cluster using the Helm package manager. The chart includes comprehensive configuration options for production deployments including security, scalability, monitoring, and reliability features.

## Chart Details

- **Chart Version**: {{ .Version | default "0.1.0" }}
- **App Version**: {{ .AppVersion | default "latest" }}
- **Kubernetes Version**: {{ .KubeVersion | default ">=1.20.0" }}
- **Generated By**: Helm Chart Specialist Agent
- **Generated At**: {{ now | date "2006-01-02 15:04:05" }}

## Prerequisites

- Kubernetes {{ .KubeVersion | default "1.20+" }}
- Helm {{ .HelmVersion | default "3.0+" }}
{{- if .Prerequisites }}
{{- range .Prerequisites }}
- {{ . }}
{{- end }}
{{- end }}

## Installation

### Add Helm Repository (if applicable)

```bash
helm repo add {{ .RepoName | default "my-repo" }} {{ .RepoURL | default "https://charts.example.com" }}
helm repo update
```

### Install the Chart

```bash
# Install with default values
helm install {{ .ReleaseName | default "my-release" }} {{ .RepoName | default "my-repo" }}/{{ .ChartName }}

# Install with custom values file
helm install {{ .ReleaseName | default "my-release" }} {{ .RepoName | default "my-repo" }}/{{ .ChartName }} -f values.yaml

# Install with inline value overrides
helm install {{ .ReleaseName | default "my-release" }} {{ .RepoName | default "my-repo" }}/{{ .ChartName }} \
  --set image.repository={{ .ImageRepository | default "nginx" }} \
  --set image.tag={{ .ImageTag | default "latest" }} \
  --set service.type=LoadBalancer
```

### Install from Local Chart

```bash
# Clone the repository
git clone {{ .SourceURL | default "https://github.com/your-org/helm-charts.git" }}
cd helm-charts/{{ .ChartName }}

# Install locally
helm install {{ .ReleaseName | default "my-release" }} .
```

## Configuration

The following table lists the configurable parameters of the {{ .ChartName }} chart and their default values.

### Global Configuration

| Parameter | Description | Default |
|-----------|-------------|---------|
| `global.imageRegistry` | Global Docker image registry | `""` |
| `global.imagePullSecrets` | Global Docker registry secret names | `[]` |
| `global.storageClass` | Global storage class for PVCs | `""` |

### Application Configuration

| Parameter | Description | Default |
|-----------|-------------|---------|
| `app.name` | Application name | `{{ .ChartName }}` |
| `app.version` | Application version | `{{ .AppVersion | default "latest" }}` |
| `app.environment` | Application environment | `production` |
| `app.tier` | Application tier | `backend` |
| `app.component` | Application component | `api` |

### Image Configuration

| Parameter | Description | Default |
|-----------|-------------|---------|
| `image.repository` | Container image repository | `{{ .ImageRepository | default "nginx" }}` |
| `image.tag` | Container image tag | `{{ .ImageTag | default "latest" }}` |
| `image.pullPolicy` | Image pull policy | `IfNotPresent` |
| `imagePullSecrets` | Image pull secrets | `[]` |

### Service Configuration

| Parameter | Description | Default |
|-----------|-------------|---------|
| `service.type` | Kubernetes service type | `ClusterIP` |
| `service.port` | Service port | `80` |
| `service.targetPort` | Target port on container | `http` |
| `service.protocol` | Service protocol | `TCP` |

### Ingress Configuration

| Parameter | Description | Default |
|-----------|-------------|---------|
| `ingress.enabled` | Enable ingress | `false` |
| `ingress.className` | Ingress class name | `""` |
| `ingress.annotations` | Ingress annotations | `{}` |
| `ingress.hosts` | Ingress hostnames | `[]` |
| `ingress.tls` | Ingress TLS configuration | `[]` |

### Security Configuration

| Parameter | Description | Default |
|-----------|-------------|---------|
| `podSecurityContext.runAsNonRoot` | Run as non-root user | `true` |
| `podSecurityContext.runAsUser` | User ID | `65534` |
| `podSecurityContext.fsGroup` | File system group ID | `65534` |
| `securityContext.allowPrivilegeEscalation` | Allow privilege escalation | `false` |
| `securityContext.readOnlyRootFilesystem` | Read-only root filesystem | `true` |
| `securityContext.capabilities.drop` | Dropped capabilities | `["ALL"]` |

### Resource Configuration

| Parameter | Description | Default |
|-----------|-------------|---------|
| `resources.limits.cpu` | CPU limit | `500m` |
| `resources.limits.memory` | Memory limit | `512Mi` |
| `resources.requests.cpu` | CPU request | `100m` |
| `resources.requests.memory` | Memory request | `128Mi` |

### Autoscaling Configuration

| Parameter | Description | Default |
|-----------|-------------|---------|
| `autoscaling.enabled` | Enable HPA | `false` |
| `autoscaling.minReplicas` | Minimum replicas | `1` |
| `autoscaling.maxReplicas` | Maximum replicas | `10` |
| `autoscaling.targetCPUUtilizationPercentage` | Target CPU utilization | `80` |
| `autoscaling.targetMemoryUtilizationPercentage` | Target memory utilization | `80` |

### Health Check Configuration

| Parameter | Description | Default |
|-----------|-------------|---------|
| `livenessProbe.httpGet.path` | Liveness probe path | `/healthz` |
| `livenessProbe.httpGet.port` | Liveness probe port | `http` |
| `livenessProbe.initialDelaySeconds` | Initial delay | `30` |
| `livenessProbe.periodSeconds` | Check period | `10` |
| `readinessProbe.httpGet.path` | Readiness probe path | `/ready` |
| `readinessProbe.httpGet.port` | Readiness probe port | `http` |
| `readinessProbe.initialDelaySeconds` | Initial delay | `5` |
| `readinessProbe.periodSeconds` | Check period | `10` |

### Persistence Configuration

| Parameter | Description | Default |
|-----------|-------------|---------|
| `persistence.enabled` | Enable persistent storage | `false` |
| `persistence.storageClass` | Storage class name | `""` |
| `persistence.accessMode` | Access mode | `ReadWriteOnce` |
| `persistence.size` | Storage size | `8Gi` |
| `persistence.mountPath` | Mount path | `/data` |

### Monitoring Configuration

| Parameter | Description | Default |
|-----------|-------------|---------|
| `monitoring.enabled` | Enable monitoring | `false` |
| `monitoring.serviceMonitor.enabled` | Enable ServiceMonitor | `false` |
| `monitoring.serviceMonitor.interval` | Scrape interval | `30s` |
| `monitoring.serviceMonitor.path` | Metrics path | `/metrics` |

## Examples

### Basic Deployment

```yaml
# values.yaml
image:
  repository: myapp/api
  tag: "1.0.0"
  pullPolicy: IfNotPresent

service:
  type: ClusterIP
  port: 80

resources:
  limits:
    cpu: 1000m
    memory: 1Gi
  requests:
    cpu: 200m
    memory: 256Mi
```

### Production Deployment with Ingress and TLS

```yaml
# values-production.yaml
replicaCount: 3

image:
  repository: myapp/api
  tag: "1.0.0"

service:
  type: ClusterIP
  port: 80

ingress:
  enabled: true
  className: nginx
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
  hosts:
    - host: api.example.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: api-tls
      hosts:
        - api.example.com

autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 20
  targetCPUUtilizationPercentage: 70

resources:
  limits:
    cpu: 2000m
    memory: 2Gi
  requests:
    cpu: 500m
    memory: 512Mi

monitoring:
  enabled: true
  serviceMonitor:
    enabled: true
    interval: 30s

networkPolicy:
  enabled: true

podDisruptionBudget:
  enabled: true
  minAvailable: 2
```

### Deployment with Persistence and Database

```yaml
# values-database.yaml
image:
  repository: postgres
  tag: "13-alpine"

service:
  port: 5432
  targetPort: 5432

persistence:
  enabled: true
  storageClass: fast-ssd
  size: 100Gi
  mountPath: /var/lib/postgresql/data

env:
  - name: POSTGRES_DB
    value: myapp
  - name: POSTGRES_USER
    valueFrom:
      secretKeyRef:
        name: postgres-credentials
        key: username
  - name: POSTGRES_PASSWORD
    valueFrom:
      secretKeyRef:
        name: postgres-credentials
        key: password

resources:
  limits:
    cpu: 4000m
    memory: 8Gi
  requests:
    cpu: 1000m
    memory: 2Gi

livenessProbe:
  exec:
    command:
      - /bin/sh
      - -c
      - pg_isready -U $POSTGRES_USER
  initialDelaySeconds: 30
  periodSeconds: 10
```

## Upgrading

### Upgrade the Chart

```bash
# Upgrade with new values
helm upgrade {{ .ReleaseName | default "my-release" }} {{ .RepoName | default "my-repo" }}/{{ .ChartName }} -f values.yaml

# Upgrade with specific version
helm upgrade {{ .ReleaseName | default "my-release" }} {{ .RepoName | default "my-repo" }}/{{ .ChartName }} --version 1.2.0
```

### Migration Notes

{{- if .MigrationNotes }}
{{ .MigrationNotes }}
{{- else }}
- Always backup persistent data before upgrading
- Check the changelog for breaking changes
- Test upgrades in a staging environment first
- Monitor application health after upgrades
{{- end }}

## Uninstalling

```bash
# Uninstall the release
helm uninstall {{ .ReleaseName | default "my-release" }}

# Uninstall and delete PVCs (if persistence is enabled)
helm uninstall {{ .ReleaseName | default "my-release" }}
kubectl delete pvc -l app.kubernetes.io/instance={{ .ReleaseName | default "my-release" }}
```

## Troubleshooting

### Common Issues

1. **Pods not starting**
   ```bash
   kubectl describe pods -l app.kubernetes.io/name={{ .ChartName }}
   kubectl logs -l app.kubernetes.io/name={{ .ChartName }}
   ```

2. **Service not accessible**
   ```bash
   kubectl get svc
   kubectl describe svc {{ .ChartName }}
   ```

3. **Ingress not working**
   ```bash
   kubectl describe ingress {{ .ChartName }}
   kubectl get events --field-selector involvedObject.name={{ .ChartName }}
   ```

4. **Persistent Volume issues**
   ```bash
   kubectl get pv,pvc
   kubectl describe pvc {{ .ChartName }}-pvc
   ```

### Debug Commands

```bash
# Get all resources
kubectl get all -l app.kubernetes.io/name={{ .ChartName }}

# Check resource events
kubectl get events --sort-by=.metadata.creationTimestamp

# Debug pod issues
kubectl describe pod -l app.kubernetes.io/name={{ .ChartName }}

# Check logs
kubectl logs -f deployment/{{ .ChartName }}

# Test connectivity
kubectl run debug --image=busybox -it --rm --restart=Never -- sh
```

### Health Checks

The chart includes comprehensive health checks:

- **Liveness Probe**: {{ .LivenessPath | default "/healthz" }} (ensures container is alive)
- **Readiness Probe**: {{ .ReadinessPath | default "/ready" }} (ensures container is ready to serve traffic)
- **Startup Probe**: {{ .StartupPath | default "/startup" }} (for slow-starting containers)

## Security

This chart implements security best practices:

- ✅ Non-root containers by default
- ✅ Read-only root filesystem
- ✅ No privilege escalation
- ✅ Dropped ALL capabilities
- ✅ Security context configuration
- ✅ Network policies (optional)
- ✅ Pod security standards
- ✅ Service account with minimal permissions

### Security Scanning

The chart supports integration with security scanners:

```bash
# Scan with Trivy
trivy k8s --report summary cluster

# Validate with Falco (if deployed)
kubectl logs -n falco daemonset/falco
```

## Monitoring and Observability

### Prometheus Integration

```yaml
monitoring:
  enabled: true
  serviceMonitor:
    enabled: true
    interval: 30s
    path: /metrics
    port: metrics
```

### Custom Metrics

Add custom metrics endpoints:

```yaml
service:
  ports:
    - name: http
      port: 80
      targetPort: 8080
    - name: metrics
      port: 9090
      targetPort: 9090
```

### Logging

Configure structured logging:

```yaml
env:
  - name: LOG_LEVEL
    value: info
  - name: LOG_FORMAT
    value: json
```

## Development

### Local Development

```bash
# Install chart locally for development
helm install dev-release . -f values-dev.yaml

# Template testing
helm template test-release . -f values.yaml

# Lint the chart
helm lint .

# Test the chart
helm test dev-release
```

### Testing

```bash
# Run chart tests
helm test {{ .ReleaseName | default "my-release" }}

# Custom test commands
kubectl run test --image=busybox --rm -it --restart=Never -- wget -qO- http://{{ .ChartName }}/health
```

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests
5. Update documentation
6. Submit a pull request

### Chart Development Guidelines

- Follow Helm best practices
- Include comprehensive tests
- Document all configuration options
- Ensure security standards compliance
- Test with multiple Kubernetes versions

## Changelog

### Version {{ .Version | default "0.1.0" }}
- Initial chart release
- Production-ready configuration
- Security hardening
- Monitoring integration
- Comprehensive documentation

{{- if .ChangelogURL }}
For detailed changelog, see: {{ .ChangelogURL }}
{{- end }}

## Support

- **Documentation**: {{ .DocsURL | default "https://github.com/your-org/helm-charts/tree/main/charts/" }}{{ .ChartName }}
- **Issues**: {{ .IssuesURL | default "https://github.com/your-org/helm-charts/issues" }}
- **Discussions**: {{ .DiscussionsURL | default "https://github.com/your-org/helm-charts/discussions" }}

## License

{{ .License | default "Apache 2.0" }}

---

*This chart was generated by the Helm Chart Specialist Agent - an AI-powered tool for creating production-ready Kubernetes deployments.*