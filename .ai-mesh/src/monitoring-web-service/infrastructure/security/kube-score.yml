# Kubernetes Security Validation Configuration (kube-score)
# Task 3.1: Advanced security scanning and validation

# Kube-score configuration for Kubernetes manifest security validation
apiVersion: v1
kind: ConfigMap
metadata:
  name: kube-score-config
  namespace: security-scanning
data:
  # Security scoring configuration
  config.yaml: |
    # Security checks configuration
    security:
      # Pod Security Standards
      pod-security-standards: "restricted"
      
      # Security context checks
      security-context:
        required: true
        run-as-non-root: true
        run-as-user-min: 1000
        read-only-root-filesystem: true
        allow-privilege-escalation: false
        drop-all-capabilities: true
        
      # Container image security
      image-security:
        disallow-latest-tag: true
        require-image-tag: true
        trusted-registries:
          - "gcr.io"
          - "registry.k8s.io"
          - "docker.io/library"
          - "public.ecr.aws"
          - "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
        
      # Network security
      network-security:
        require-network-policies: true
        disallow-host-network: true
        disallow-host-port: true
        disallow-node-port: false  # Allow for specific use cases
        
      # Resource security
      resource-security:
        require-resource-requests: true
        require-resource-limits: true
        require-memory-requests: true
        require-memory-limits: true
        require-cpu-requests: true
        require-cpu-limits: true
        
    # Resource-specific configurations
    deployment:
      # Replica configuration
      replicas:
        min-replicas: 2  # High availability requirement
        max-replicas: 100
        
      # Rolling update strategy
      rolling-update:
        max-unavailable: "25%"
        max-surge: "25%"
        
      # Pod disruption budget
      pod-disruption-budget:
        required: true
        min-available: "50%"
        
      # Probes configuration
      probes:
        liveness-probe:
          required: true
          initial-delay-seconds-min: 10
          period-seconds-max: 30
          timeout-seconds-max: 10
          failure-threshold-max: 5
          
        readiness-probe:
          required: true
          initial-delay-seconds-min: 5
          period-seconds-max: 10
          timeout-seconds-max: 5
          failure-threshold-max: 3
          
        startup-probe:
          recommended: true
          
    service:
      # Service type validation
      type-validation:
        allowed-types: ["ClusterIP", "NodePort", "LoadBalancer"]
        disallow-external-name: true
        
      # Port configuration
      ports:
        require-named-ports: true
        disallow-privileged-ports: true  # < 1024
        
    ingress:
      # TLS configuration
      tls:
        require-tls: true
        require-valid-cert: true
        
      # Annotation validation
      annotations:
        required-annotations:
          - "kubernetes.io/ingress.class"
          - "nginx.ingress.kubernetes.io/ssl-redirect"
          
    configmap:
      # Data validation
      data-validation:
        disallow-sensitive-data: true
        sensitive-patterns:
          - "password"
          - "secret"
          - "key"
          - "token"
          - "credential"
          
    secret:
      # Secret validation
      secret-validation:
        require-type: true
        allowed-types:
          - "Opaque"
          - "kubernetes.io/tls"
          - "kubernetes.io/service-account-token"
          - "kubernetes.io/dockerconfigjson"
        disallow-string-data: false  # Allow for generated secrets
        
    # Environment-specific overrides
    environments:
      development:
        security:
          pod-security-standards: "baseline"
        deployment:
          replicas:
            min-replicas: 1
        resource-security:
          require-resource-limits: false
          
      staging:
        security:
          pod-security-standards: "restricted"
        deployment:
          replicas:
            min-replicas: 2
            
      production:
        security:
          pod-security-standards: "restricted"
          additional-security-checks: true
        deployment:
          replicas:
            min-replicas: 3
          pod-disruption-budget:
            min-available: "66%"
            
    # Custom scoring rules
    custom-rules:
      # Metadata validation
      - name: "metadata-labels"
        description: "Ensure required labels are present"
        severity: "warning"
        required-labels:
          - "app"
          - "version"
          - "component"
          - "managed-by"
          - "environment"
          
      - name: "resource-naming"
        description: "Ensure consistent naming conventions"
        severity: "warning"
        naming-patterns:
          - "^[a-z][a-z0-9-]*[a-z0-9]$"  # kebab-case
          
      - name: "annotation-validation"
        description: "Validate required annotations"
        severity: "info"
        required-annotations:
          - "deployment.kubernetes.io/revision"
          - "kubectl.kubernetes.io/last-applied-configuration"
          
    # Scoring weights
    scoring:
      security-weight: 0.4
      reliability-weight: 0.3
      performance-weight: 0.2
      maintainability-weight: 0.1
      
    # Output configuration
    output:
      format: "json"
      include-passed: true
      include-skipped: false
      verbose: true
      
      # Scoring thresholds
      thresholds:
        fail-below: 7.0    # Fail if score < 7.0
        warn-below: 8.5    # Warn if score < 8.5
        excellent-above: 9.5  # Excellent if score > 9.5
        
    # Integration configuration
    integrations:
      # CI/CD integration
      ci-cd:
        junit-output: true
        sarif-output: true
        badge-generation: true
        
      # Monitoring integration
      monitoring:
        prometheus-metrics: true
        grafana-dashboard: true
        
      # Alerting integration
      alerting:
        slack-webhook: "${SLACK_WEBHOOK_URL}"
        alert-on-score-drop: true
        score-drop-threshold: 1.0

---
# Kube-score execution script
apiVersion: v1
kind: ConfigMap
metadata:
  name: kube-score-script
  namespace: security-scanning
data:
  run-kube-score.sh: |
    #!/bin/bash
    set -euo pipefail
    
    # Configuration
    KUBE_SCORE_VERSION="1.16.1"
    MANIFESTS_DIR="${1:-/manifests}"
    OUTPUT_DIR="${2:-/output}"
    ENVIRONMENT="${3:-development}"
    
    # Colors for output
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    NC='\033[0m' # No Color
    
    echo -e "${BLUE}üîç Starting Kubernetes security validation with kube-score${NC}"
    echo "Environment: ${ENVIRONMENT}"
    echo "Manifests directory: ${MANIFESTS_DIR}"
    echo "Output directory: ${OUTPUT_DIR}"
    
    # Create output directory
    mkdir -p "${OUTPUT_DIR}"
    
    # Function to run kube-score on a file
    run_kube_score() {
        local file=$1
        local filename=$(basename "${file}")
        local output_file="${OUTPUT_DIR}/${filename}.json"
        
        echo -e "${BLUE}üìã Scanning ${filename}...${NC}"
        
        if kube-score score "${file}" \
            --output-format json \
            --output-version v2 \
            > "${output_file}" 2>&1; then
            echo -e "${GREEN}‚úÖ ${filename} scan completed${NC}"
        else
            echo -e "${RED}‚ùå ${filename} scan failed${NC}"
            return 1
        fi
        
        # Parse results for immediate feedback
        local score=$(jq -r '.score // "N/A"' "${output_file}")
        local critical_issues=$(jq -r '[.checks[] | select(.grade == "CRITICAL")] | length' "${output_file}")
        local warnings=$(jq -r '[.checks[] | select(.grade == "WARNING")] | length' "${output_file}")
        
        echo -e "${BLUE}üìä Results for ${filename}:${NC}"
        echo -e "   Score: ${score}"
        echo -e "   Critical Issues: ${critical_issues}"
        echo -e "   Warnings: ${warnings}"
        
        if [[ "${critical_issues}" -gt 0 ]]; then
            echo -e "${RED}üö® Critical security issues found in ${filename}${NC}"
            jq -r '.checks[] | select(.grade == "CRITICAL") | "  - \(.check): \(.comment)"' "${output_file}"
            return 1
        fi
    }
    
    # Find and scan all Kubernetes manifest files
    total_files=0
    failed_files=0
    
    while IFS= read -r -d '' file; do
        ((total_files++))
        if ! run_kube_score "${file}"; then
            ((failed_files++))
        fi
        echo # Add spacing between files
    done < <(find "${MANIFESTS_DIR}" -type f \( -name "*.yaml" -o -name "*.yml" \) -print0)
    
    # Generate consolidated report
    echo -e "${BLUE}üìä Generating consolidated security report...${NC}"
    
    cat > "${OUTPUT_DIR}/security-summary.json" <<EOF
    {
      "scan_timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
      "environment": "${ENVIRONMENT}",
      "total_files_scanned": ${total_files},
      "files_with_issues": ${failed_files},
      "scan_success_rate": $(echo "scale=2; (${total_files} - ${failed_files}) * 100 / ${total_files}" | bc)
    }
    EOF
    
    # Merge all individual results
    jq -s 'map(select(. != null))' "${OUTPUT_DIR}"/*.json > "${OUTPUT_DIR}/complete-results.json"
    
    # Generate human-readable report
    cat > "${OUTPUT_DIR}/security-report.md" <<EOF
    # Kubernetes Security Validation Report
    
    **Scan Date:** $(date -u)
    **Environment:** ${ENVIRONMENT}
    **Scanner:** kube-score v${KUBE_SCORE_VERSION}
    
    ## Summary
    - **Total Files Scanned:** ${total_files}
    - **Files with Critical Issues:** ${failed_files}
    - **Success Rate:** $(echo "scale=2; (${total_files} - ${failed_files}) * 100 / ${total_files}" | bc)%
    
    ## Detailed Results
    EOF
    
    # Add detailed results for each file
    for result_file in "${OUTPUT_DIR}"/*.json; do
        if [[ $(basename "${result_file}") != "security-summary.json" ]] && [[ $(basename "${result_file}") != "complete-results.json" ]]; then
            local manifest_name=$(basename "${result_file}" .json)
            echo "### ${manifest_name}" >> "${OUTPUT_DIR}/security-report.md"
            jq -r '.checks[] | "- **\(.check)**: \(.comment) (Grade: \(.grade))"' "${result_file}" >> "${OUTPUT_DIR}/security-report.md"
            echo >> "${OUTPUT_DIR}/security-report.md"
        fi
    done
    
    # Final results
    echo -e "${BLUE}üìà Security validation completed${NC}"
    echo -e "Total files scanned: ${total_files}"
    echo -e "Files with critical issues: ${failed_files}"
    
    if [[ ${failed_files} -eq 0 ]]; then
        echo -e "${GREEN}üéâ All Kubernetes manifests passed security validation!${NC}"
        exit 0
    else
        echo -e "${RED}‚ö†Ô∏è ${failed_files} file(s) have critical security issues that must be resolved${NC}"
        exit 1
    fi

---
# Polaris integration configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: polaris-config
  namespace: security-scanning
data:
  config.yaml: |
    # Polaris configuration for advanced Kubernetes security validation
    checks:
      # Security checks
      runAsNonRoot: warning
      runAsRootAllowed: danger
      notReadOnlyRootFilesystem: warning
      privilegeEscalationAllowed: danger
      insecureCapabilities: warning
      dangerousCapabilities: danger
      
      # Image security
      tagNotSpecified: danger
      pullPolicyNotAlways: ignore  # Allow for performance
      
      # Networking
      hostNetworkSet: danger
      hostPortSet: danger
      
      # Resources
      cpuRequestsMissing: warning
      cpuLimitsMissing: warning
      memoryRequestsMissing: warning
      memoryLimitsMissing: warning
      
      # Probes
      readinessProbeMissing: warning
      livenessProbeMissing: warning
      
      # Metadata
      metadataAndNameMismatched: ignore
      
      # Service Account
      automountServiceAccountToken: warning
      
    # Custom mutations for environment-specific requirements
    mutations:
      - name: "Add security context"
        match:
          - apiVersion: "apps/v1"
            kind: "Deployment"
        mutate:
          spec:
            template:
              spec:
                securityContext:
                  runAsNonRoot: true
                  runAsUser: 1000
                  fsGroup: 2000
                containers:
                  - securityContext:
                      allowPrivilegeEscalation: false
                      readOnlyRootFilesystem: true
                      capabilities:
                        drop:
                          - ALL
      
      - name: "Add resource limits"
        match:
          - apiVersion: "apps/v1"
            kind: "Deployment"
        mutate:
          spec:
            template:
              spec:
                containers:
                  - resources:
                      requests:
                        memory: "64Mi"
                        cpu: "50m"
                      limits:
                        memory: "128Mi"
                        cpu: "100m"
                        
    # Environment-specific configurations
    environments:
      development:
        checks:
          cpuLimitsMissing: ignore
          memoryLimitsMissing: ignore
          
      staging:
        checks:
          cpuLimitsMissing: warning
          memoryLimitsMissing: warning
          
      production:
        checks:
          cpuLimitsMissing: danger
          memoryLimitsMissing: danger
          notReadOnlyRootFilesystem: danger