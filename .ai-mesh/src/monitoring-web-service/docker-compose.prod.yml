# Docker Compose Production Configuration
# Production-ready configuration with optimized settings and security

version: '3.8'

services:
  # Production application configuration
  metrics-api:
    image: ${REGISTRY_URL:-fortium}/metrics-web-service:${IMAGE_TAG:-latest}
    build:
      target: production
      args:
        - NODE_ENV=production
    environment:
      # Production environment variables
      - NODE_ENV=production
      - LOG_LEVEL=info
      # Production database connection with SSL
      - DB_SSL_MODE=require
      - DB_POOL_SIZE=50
      # Enhanced security
      - HELMET_CSP_ENABLED=true
      - RATE_LIMITING_ENABLED=true
      # Production performance settings
      - CLUSTER_MODE=true
      - CLUSTER_WORKERS=0  # Use all available CPUs
      - CACHE_TTL_SECONDS=600
      - MAX_BATCH_SIZE=5000
    # Production resource limits
    deploy:
      replicas: 3
      resources:
        limits:
          memory: 1g
          cpus: '0.5'
        reservations:
          memory: 512m
          cpus: '0.25'
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
      update_config:
        parallelism: 1
        delay: 30s
        failure_action: rollback
        monitor: 60s
    # Health checks for production
    healthcheck:
      test: ["CMD", "node", "-e", "require('http').get('http://localhost:3000/api/health', (res) => process.exit(res.statusCode === 200 ? 0 : 1)).on('error', () => process.exit(1))"]
      interval: 30s
      timeout: 10s
      start_period: 60s
      retries: 3
    # Security context
    user: "1001:1001"
    read_only: true
    tmpfs:
      - /tmp
      - /app/logs
    # Logging configuration
    logging:
      driver: "json-file"
      options:
        max-size: "50m"
        max-file: "5"

  # Production PostgreSQL configuration
  postgres:
    image: timescale/timescaledb:latest-pg14
    environment:
      # Production database configuration
      - POSTGRES_PASSWORD_FILE=/run/secrets/postgres_password
      - POSTGRES_USER_FILE=/run/secrets/postgres_user
      - POSTGRES_DB_FILE=/run/secrets/postgres_database
    # Production-optimized PostgreSQL settings
    command: |
      postgres
      -c shared_preload_libraries=timescaledb,pg_stat_statements
      -c max_connections=200
      -c shared_buffers=1GB
      -c effective_cache_size=4GB
      -c maintenance_work_mem=256MB
      -c checkpoint_completion_target=0.9
      -c wal_buffers=64MB
      -c default_statistics_target=100
      -c random_page_cost=1.1
      -c effective_io_concurrency=200
      -c work_mem=8MB
      -c min_wal_size=2GB
      -c max_wal_size=8GB
      -c max_worker_processes=8
      -c max_parallel_workers_per_gather=4
      -c max_parallel_workers=8
      -c max_parallel_maintenance_workers=4
      -c log_min_duration_statement=1000
      -c log_checkpoints=on
      -c log_connections=on
      -c log_disconnections=on
      -c log_lock_waits=on
      -c ssl=on
      -c ssl_cert_file=/etc/ssl/certs/server.crt
      -c ssl_key_file=/etc/ssl/private/server.key
    deploy:
      resources:
        limits:
          memory: 4g
          cpus: '2.0'
        reservations:
          memory: 2g
          cpus: '1.0'
    # Production volumes with backup considerations
    volumes:
      - postgres-data:/var/lib/postgresql/data
      - postgres-backup:/backup
      - ./ssl:/etc/ssl:ro
    secrets:
      - postgres_password
      - postgres_user
      - postgres_database
    # Enhanced health checks
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $(cat /run/secrets/postgres_user) -d $(cat /run/secrets/postgres_database)"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 60s

  # Production Redis configuration
  redis:
    image: redis:7-alpine
    environment:
      - REDIS_PASSWORD_FILE=/run/secrets/redis_password
    command: |
      redis-server
      --requirepass $(cat /run/secrets/redis_password)
      --maxmemory 2gb
      --maxmemory-policy allkeys-lru
      --save 900 1
      --save 300 10
      --save 60 10000
      --appendonly yes
      --appendfsync everysec
      --tcp-keepalive 300
      --tcp-backlog 511
      --timeout 300
      --databases 16
      --maxclients 10000
      --bind 0.0.0.0
      --protected-mode yes
    deploy:
      resources:
        limits:
          memory: 2g
          cpus: '0.5'
        reservations:
          memory: 1g
          cpus: '0.25'
    volumes:
      - redis-data:/data
      - redis-backup:/backup
    secrets:
      - redis_password
    healthcheck:
      test: ["CMD", "redis-cli", "--no-auth-warning", "-a", "$$(cat /run/secrets/redis_password)", "ping"]
      interval: 30s
      timeout: 5s
      retries: 3

  # Production PostgreSQL exporter
  postgres-exporter:
    image: quay.io/prometheuscommunity/postgres-exporter:v0.15.0
    environment:
      - DATA_SOURCE_NAME=postgresql://$(cat /run/secrets/postgres_user):$(cat /run/secrets/postgres_password)@postgres:5432/$(cat /run/secrets/postgres_database)?sslmode=require
      - PG_EXPORTER_AUTO_DISCOVER_DATABASES=true
      - PG_EXPORTER_EXCLUDE_DATABASES=postgres,template0,template1
      - PG_EXPORTER_DISABLE_DEFAULT_METRICS=false
      - PG_EXPORTER_CONSTANT_LABELS=environment=production,cluster=main
    deploy:
      resources:
        limits:
          memory: 256m
          cpus: '0.1'
        reservations:
          memory: 128m
          cpus: '0.05'
    secrets:
      - postgres_password
      - postgres_user
      - postgres_database
    # Security context
    user: "65534:65534"
    read_only: true

  # Production backup service
  backup-service:
    image: postgres:14-alpine
    environment:
      - PGUSER_FILE=/run/secrets/postgres_user
      - PGPASSWORD_FILE=/run/secrets/postgres_password
      - PGDATABASE_FILE=/run/secrets/postgres_database
    volumes:
      - postgres-backup:/backup
      - ./scripts/backup:/scripts:ro
    secrets:
      - postgres_password
      - postgres_user
      - postgres_database
    entrypoint: ["/scripts/backup.sh"]
    deploy:
      replicas: 1
      restart_policy:
        condition: none
    profiles:
      - backup

  # Production log aggregation
  log-aggregator:
    image: fluent/fluent-bit:latest
    volumes:
      - /var/log:/var/log:ro
      - ./fluent-bit/fluent-bit.conf:/fluent-bit/etc/fluent-bit.conf:ro
    deploy:
      mode: global
      resources:
        limits:
          memory: 128m
          cpus: '0.1'
    networks:
      - metrics-network
    profiles:
      - production
      - logging

# Production volumes with optimized drivers
volumes:
  postgres-data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /data/postgres

  postgres-backup:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /backup/postgres

  redis-data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /data/redis

  redis-backup:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /backup/redis

# Production secrets
secrets:
  postgres_password:
    external: true
    name: metrics_postgres_password

  postgres_user:
    external: true
    name: metrics_postgres_user

  postgres_database:
    external: true
    name: metrics_postgres_database

  redis_password:
    external: true
    name: metrics_redis_password

  jwt_secret:
    external: true
    name: metrics_jwt_secret

  jwt_refresh_secret:
    external: true
    name: metrics_jwt_refresh_secret

# Production network configuration
networks:
  metrics-network:
    driver: overlay
    driver_opts:
      encrypted: "true"
    ipam:
      config:
        - subnet: 10.1.0.0/16
          gateway: 10.1.0.1
    labels:
      - "environment=production"
      - "project=monitoring-web-service"