# Production Deployment Pipeline
# Comprehensive production deployment with advanced validation and rollback capabilities
# Phase 2: Infrastructure & Integration - Production Deployment Automation

name: Deploy to Production

on:
  # Manual deployment trigger with approval
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Docker image tag to deploy'
        required: true
        type: string
      deployment_strategy:
        description: 'Deployment strategy'
        required: false
        default: 'rolling'
        type: choice
        options:
          - 'rolling'
          - 'blue-green'
          - 'canary'
      environment:
        description: 'Target environment'
        required: false
        default: 'production'
        type: choice
        options:
          - 'staging'
          - 'production'
      skip_tests:
        description: 'Skip pre-deployment tests'
        required: false
        default: false
        type: boolean
      auto_rollback:
        description: 'Enable automatic rollback on failure'
        required: false
        default: true
        type: boolean

  # Automatic deployment from main branch (with approval)
  push:
    branches: [ main ]
    paths-ignore:
      - 'docs/**'
      - '*.md'
      - '.github/workflows/security-scan.yml'
      - '.github/workflows/performance-test.yml'

# Set concurrency for production deployments
concurrency:
  group: production-deployment
  cancel-in-progress: false

env:
  AWS_REGION: us-west-2
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com
  ECR_REPOSITORY: fortium-metrics-web-service
  EKS_CLUSTER_NAME: fortium-metrics-production-eks
  KUBECTL_VERSION: 1.28.0
  HELM_VERSION: 3.13.0

jobs:
  # Pre-deployment validation
  pre-deployment-validation:
    name: Pre-Deployment Validation
    runs-on: ubuntu-latest
    if: ${{ !inputs.skip_tests }}
    
    outputs:
      image-exists: ${{ steps.check-image.outputs.exists }}
      current-version: ${{ steps.get-current.outputs.version }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Determine image tag
        id: image-tag
        run: |
          if [ "${{ github.event.inputs.image_tag }}" != "" ]; then
            echo "tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
          else
            echo "tag=${GITHUB_SHA:0:7}" >> $GITHUB_OUTPUT
          fi

      - name: Check if Docker image exists
        id: check-image
        run: |
          IMAGE_TAG="${{ steps.image-tag.outputs.tag }}"
          if aws ecr describe-images --repository-name ${{ env.ECR_REPOSITORY }} --image-ids imageTag=${IMAGE_TAG} >/dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "✅ Docker image ${IMAGE_TAG} exists in ECR"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "❌ Docker image ${IMAGE_TAG} does not exist in ECR"
            exit 1
          fi

      - name: Get current production version
        id: get-current
        run: |
          # Connect to EKS cluster
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}
          
          # Get current deployment image
          CURRENT_IMAGE=$(kubectl get deployment monitoring-web-service -n production -o jsonpath='{.spec.template.spec.containers[0].image}' 2>/dev/null || echo "none")
          CURRENT_VERSION=$(echo $CURRENT_IMAGE | cut -d':' -f2)
          
          echo "version=${CURRENT_VERSION}" >> $GITHUB_OUTPUT
          echo "Current production version: ${CURRENT_VERSION}"

      - name: Run smoke tests on staging
        run: |
          # Basic health check on staging
          STAGING_URL="https://metrics-staging.yourdomain.com"
          
          echo "Running smoke tests on staging..."
          
          # Health check
          if ! curl -f "${STAGING_URL}/api/health" >/dev/null 2>&1; then
            echo "❌ Staging health check failed"
            exit 1
          fi
          
          # Basic API test
          if ! curl -f "${STAGING_URL}/api/metrics" -H "Content-Type: application/json" >/dev/null 2>&1; then
            echo "❌ Staging API test failed"
            exit 1
          fi
          
          echo "✅ Staging smoke tests passed"

      - name: Validate Helm chart
        run: |
          # Install Helm
          curl https://get.helm.sh/helm-v${{ env.HELM_VERSION }}-linux-amd64.tar.gz | tar xz
          sudo mv linux-amd64/helm /usr/local/bin/
          
          # Validate Helm chart
          helm lint helm-chart/monitoring-web-service/
          helm template monitoring-web-service helm-chart/monitoring-web-service/ \
            --values helm-chart/monitoring-web-service/values-prod.yaml \
            --set app.image.tag=${{ steps.image-tag.outputs.tag }} \
            --dry-run --debug

  # Deployment approval (for production)
  deployment-approval:
    name: Deployment Approval
    runs-on: ubuntu-latest
    needs: pre-deployment-validation
    if: ${{ github.event.inputs.environment == 'production' || (github.ref == 'refs/heads/main' && github.event_name == 'push') }}
    
    environment:
      name: production-approval
      url: https://metrics.yourdomain.com
    
    steps:
      - name: Request deployment approval
        run: |
          echo "🚀 Production deployment requested"
          echo "Image tag: ${{ github.event.inputs.image_tag || github.sha }}"
          echo "Strategy: ${{ github.event.inputs.deployment_strategy || 'rolling' }}"
          echo "Auto-rollback: ${{ github.event.inputs.auto_rollback || 'true' }}"

  # Production deployment
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [pre-deployment-validation, deployment-approval]
    if: always() && needs.pre-deployment-validation.result == 'success' && (needs.deployment-approval.result == 'success' || needs.deployment-approval.result == 'skipped')
    
    environment:
      name: production
      url: https://metrics.yourdomain.com
    
    outputs:
      deployment-id: ${{ steps.deploy.outputs.deployment-id }}
      previous-version: ${{ needs.pre-deployment-validation.outputs.current-version }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Kubernetes tools
        run: |
          # Install kubectl
          curl -LO "https://dl.k8s.io/release/v${{ env.KUBECTL_VERSION }}/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          
          # Install Helm
          curl https://get.helm.sh/helm-v${{ env.HELM_VERSION }}-linux-amd64.tar.gz | tar xz
          sudo mv linux-amd64/helm /usr/local/bin/
          
          # Connect to EKS cluster
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

      - name: Prepare deployment
        id: prepare
        run: |
          IMAGE_TAG="${{ github.event.inputs.image_tag || github.sha }}"
          DEPLOYMENT_STRATEGY="${{ github.event.inputs.deployment_strategy || 'rolling' }}"
          
          echo "tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "strategy=${DEPLOYMENT_STRATEGY}" >> $GITHUB_OUTPUT
          
          # Create deployment ID
          DEPLOYMENT_ID="deploy-$(date +%Y%m%d-%H%M%S)-${IMAGE_TAG:0:7}"
          echo "deployment-id=${DEPLOYMENT_ID}" >> $GITHUB_OUTPUT
          
          # Create backup of current state
          kubectl get deployment monitoring-web-service -n production -o yaml > backup-deployment.yaml
          kubectl get service monitoring-web-service -n production -o yaml > backup-service.yaml
          kubectl get configmap -n production -l app=monitoring-web-service -o yaml > backup-configmaps.yaml

      - name: Deploy with Rolling Update
        if: ${{ steps.prepare.outputs.strategy == 'rolling' }}
        id: deploy-rolling
        run: |
          echo "🚀 Starting rolling deployment..."
          
          # Update Helm deployment
          helm upgrade monitoring-web-service helm-chart/monitoring-web-service/ \
            --namespace production \
            --values helm-chart/monitoring-web-service/values-prod.yaml \
            --set app.image.tag=${{ steps.prepare.outputs.tag }} \
            --set app.deploymentStrategy.type=RollingUpdate \
            --set app.deploymentStrategy.rollingUpdate.maxSurge=1 \
            --set app.deploymentStrategy.rollingUpdate.maxUnavailable=0 \
            --wait --timeout=10m
          
          echo "deployment-id=${{ steps.prepare.outputs.deployment-id }}" >> $GITHUB_OUTPUT

      - name: Deploy with Blue-Green Strategy
        if: ${{ steps.prepare.outputs.strategy == 'blue-green' }}
        id: deploy-blue-green
        run: |
          echo "🔄 Starting blue-green deployment..."
          
          # Create green environment
          helm install monitoring-web-service-green helm-chart/monitoring-web-service/ \
            --namespace production \
            --values helm-chart/monitoring-web-service/values-prod.yaml \
            --set app.image.tag=${{ steps.prepare.outputs.tag }} \
            --set service.selector.version=green \
            --set app.labels.version=green \
            --wait --timeout=10m
          
          # Wait for green to be ready
          kubectl wait --for=condition=available --timeout=300s deployment/monitoring-web-service-green -n production
          
          # Switch traffic to green
          kubectl patch service monitoring-web-service -n production -p '{"spec":{"selector":{"version":"green"}}}'
          
          # Verify green is receiving traffic
          sleep 30
          curl -f https://metrics.yourdomain.com/api/health
          
          # Remove blue environment
          helm uninstall monitoring-web-service -n production || true
          
          # Promote green to main
          helm upgrade monitoring-web-service helm-chart/monitoring-web-service/ \
            --namespace production \
            --values helm-chart/monitoring-web-service/values-prod.yaml \
            --set app.image.tag=${{ steps.prepare.outputs.tag }} \
            --reuse-values
          
          echo "deployment-id=${{ steps.prepare.outputs.deployment-id }}" >> $GITHUB_OUTPUT

      - name: Deploy with Canary Strategy
        if: ${{ steps.prepare.outputs.strategy == 'canary' }}
        id: deploy-canary
        run: |
          echo "🐦 Starting canary deployment..."
          
          # Deploy canary (10% traffic)
          helm install monitoring-web-service-canary helm-chart/monitoring-web-service/ \
            --namespace production \
            --values helm-chart/monitoring-web-service/values-prod.yaml \
            --set app.image.tag=${{ steps.prepare.outputs.tag }} \
            --set app.replicaCount=1 \
            --set service.selector.version=canary \
            --set app.labels.version=canary \
            --wait --timeout=10m
          
          # Configure traffic split (90% stable, 10% canary)
          kubectl apply -f - <<EOF
          apiVersion: networking.istio.io/v1alpha3
          kind: VirtualService
          metadata:
            name: monitoring-web-service
            namespace: production
          spec:
            http:
            - match:
              - headers:
                  canary:
                    exact: "true"
              route:
              - destination:
                  host: monitoring-web-service-canary
            - route:
              - destination:
                  host: monitoring-web-service
                weight: 90
              - destination:
                  host: monitoring-web-service-canary
                weight: 10
          EOF
          
          # Monitor canary for 5 minutes
          echo "Monitoring canary deployment for 5 minutes..."
          sleep 300
          
          # Check canary metrics
          CANARY_ERROR_RATE=$(curl -s "https://metrics.yourdomain.com/api/metrics/error-rate?version=canary" | jq '.error_rate')
          
          if (( $(echo "${CANARY_ERROR_RATE} > 0.05" | bc -l) )); then
            echo "❌ Canary error rate too high: ${CANARY_ERROR_RATE}"
            exit 1
          fi
          
          # Promote canary to full deployment
          helm upgrade monitoring-web-service helm-chart/monitoring-web-service/ \
            --namespace production \
            --values helm-chart/monitoring-web-service/values-prod.yaml \
            --set app.image.tag=${{ steps.prepare.outputs.tag }} \
            --wait --timeout=10m
          
          # Remove canary
          helm uninstall monitoring-web-service-canary -n production
          kubectl delete virtualservice monitoring-web-service -n production
          
          echo "deployment-id=${{ steps.prepare.outputs.deployment-id }}" >> $GITHUB_OUTPUT

      - name: Set deployment output
        id: deploy
        run: |
          if [ "${{ steps.deploy-rolling.outputs.deployment-id }}" != "" ]; then
            echo "deployment-id=${{ steps.deploy-rolling.outputs.deployment-id }}" >> $GITHUB_OUTPUT
          elif [ "${{ steps.deploy-blue-green.outputs.deployment-id }}" != "" ]; then
            echo "deployment-id=${{ steps.deploy-blue-green.outputs.deployment-id }}" >> $GITHUB_OUTPUT
          elif [ "${{ steps.deploy-canary.outputs.deployment-id }}" != "" ]; then
            echo "deployment-id=${{ steps.deploy-canary.outputs.deployment-id }}" >> $GITHUB_OUTPUT
          fi

      - name: Upload deployment artifacts
        uses: actions/upload-artifact@v4
        with:
          name: deployment-backup-${{ steps.prepare.outputs.deployment-id }}
          path: backup-*.yaml
          retention-days: 30

  # Post-deployment validation
  post-deployment-validation:
    name: Post-Deployment Validation
    runs-on: ubuntu-latest
    needs: deploy-production
    if: always() && needs.deploy-production.result == 'success'
    
    steps:
      - name: Wait for deployment stabilization
        run: |
          echo "Waiting for deployment to stabilize..."
          sleep 60

      - name: Health check validation
        run: |
          echo "Running post-deployment health checks..."
          
          # Health endpoint
          for i in {1..10}; do
            if curl -f https://metrics.yourdomain.com/api/health; then
              echo "✅ Health check passed (attempt $i)"
              break
            else
              echo "❌ Health check failed (attempt $i)"
              if [ $i -eq 10 ]; then exit 1; fi
              sleep 30
            fi
          done

      - name: Functional testing
        run: |
          echo "Running functional tests..."
          
          # Test metrics submission
          RESPONSE=$(curl -s -X POST https://metrics.yourdomain.com/api/metrics \
            -H "Content-Type: application/json" \
            -d '{"timestamp":"'$(date -Iseconds)'","value":100,"tags":{"test":"deployment"}}')
          
          if echo "$RESPONSE" | jq -e '.success' >/dev/null; then
            echo "✅ Metrics submission test passed"
          else
            echo "❌ Metrics submission test failed"
            exit 1
          fi
          
          # Test metrics query
          QUERY_RESPONSE=$(curl -s "https://metrics.yourdomain.com/api/metrics?from=$(date -d '1 hour ago' -Iseconds)")
          
          if echo "$QUERY_RESPONSE" | jq -e '.data' >/dev/null; then
            echo "✅ Metrics query test passed"
          else
            echo "❌ Metrics query test failed"
            exit 1
          fi

      - name: Performance validation
        run: |
          echo "Running performance validation..."
          
          # Response time check
          RESPONSE_TIME=$(curl -w "%{time_total}" -s -o /dev/null https://metrics.yourdomain.com/api/health)
          
          if (( $(echo "${RESPONSE_TIME} < 1.0" | bc -l) )); then
            echo "✅ Response time validation passed: ${RESPONSE_TIME}s"
          else
            echo "❌ Response time validation failed: ${RESPONSE_TIME}s"
            exit 1
          fi

      - name: Database connectivity check
        run: |
          echo "Checking database connectivity through API..."
          
          DB_STATUS=$(curl -s https://metrics.yourdomain.com/api/health/database | jq -r '.status')
          
          if [ "$DB_STATUS" = "healthy" ]; then
            echo "✅ Database connectivity check passed"
          else
            echo "❌ Database connectivity check failed: $DB_STATUS"
            exit 1
          fi

  # Automatic rollback on validation failure
  rollback-on-failure:
    name: Automatic Rollback
    runs-on: ubuntu-latest
    needs: [deploy-production, post-deployment-validation]
    if: ${{ failure() && github.event.inputs.auto_rollback != 'false' && needs.deploy-production.result == 'success' }}
    
    environment:
      name: production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Kubernetes tools
        run: |
          curl -LO "https://dl.k8s.io/release/v${{ env.KUBECTL_VERSION }}/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          
          curl https://get.helm.sh/helm-v${{ env.HELM_VERSION }}-linux-amd64.tar.gz | tar xz
          sudo mv linux-amd64/helm /usr/local/bin/
          
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

      - name: Download backup artifacts
        uses: actions/download-artifact@v4
        with:
          name: deployment-backup-${{ needs.deploy-production.outputs.deployment-id }}

      - name: Perform rollback
        run: |
          echo "🔄 Performing automatic rollback to previous version..."
          
          PREVIOUS_VERSION="${{ needs.deploy-production.outputs.previous-version }}"
          
          if [ "$PREVIOUS_VERSION" != "none" ] && [ "$PREVIOUS_VERSION" != "" ]; then
            echo "Rolling back to version: $PREVIOUS_VERSION"
            
            helm rollback monitoring-web-service -n production || {
              echo "Helm rollback failed, using kubectl..."
              kubectl apply -f backup-deployment.yaml
              kubectl apply -f backup-service.yaml
              kubectl apply -f backup-configmaps.yaml
            }
            
            # Wait for rollback to complete
            kubectl rollout status deployment/monitoring-web-service -n production --timeout=300s
            
            # Verify rollback
            sleep 30
            curl -f https://metrics.yourdomain.com/api/health
            
            echo "✅ Rollback completed successfully"
          else
            echo "❌ Cannot rollback: no previous version found"
            exit 1
          fi

  # Deployment notification
  notify-deployment:
    name: Deployment Notification
    runs-on: ubuntu-latest
    needs: [deploy-production, post-deployment-validation, rollback-on-failure]
    if: always() && needs.deploy-production.result != 'skipped'
    
    steps:
      - name: Determine deployment status
        id: status
        run: |
          if [ "${{ needs.post-deployment-validation.result }}" = "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "message=✅ Production deployment completed successfully" >> $GITHUB_OUTPUT
          elif [ "${{ needs.rollback-on-failure.result }}" = "success" ]; then
            echo "status=rollback" >> $GITHUB_OUTPUT
            echo "message=🔄 Deployment failed and was rolled back successfully" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "message=❌ Production deployment failed" >> $GITHUB_OUTPUT
          fi

      - name: Send Slack notification
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ steps.status.outputs.status == 'success' && 'success' || 'failure' }}
          channel: '#deployments'
          title: 'Production Deployment'
          text: |
            ${{ steps.status.outputs.message }}
            
            Repository: ${{ github.repository }}
            Image Tag: ${{ github.event.inputs.image_tag || github.sha }}
            Strategy: ${{ github.event.inputs.deployment_strategy || 'rolling' }}
            Deployment ID: ${{ needs.deploy-production.outputs.deployment-id }}
            Actor: ${{ github.actor }}
            
            URL: https://metrics.yourdomain.com
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.DEPLOYMENT_SLACK_WEBHOOK_URL }}

      - name: Create GitHub release
        if: ${{ steps.status.outputs.status == 'success' && github.event_name == 'push' }}
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: "v${{ github.run_number }}"
          release_name: "Production Release v${{ github.run_number }}"
          body: |
            ## 🚀 Production Deployment
            
            **Image Tag:** `${{ github.event.inputs.image_tag || github.sha }}`
            **Deployment Strategy:** ${{ github.event.inputs.deployment_strategy || 'rolling' }}
            **Deployment ID:** ${{ needs.deploy-production.outputs.deployment-id }}
            
            ### Changes
            ${{ github.event.head_commit.message }}
            
            ### Validation Results
            - ✅ Health checks passed
            - ✅ Functional tests passed  
            - ✅ Performance validation passed
            - ✅ Database connectivity verified
            
            **Deployed to:** https://metrics.yourdomain.com
          draft: false
          prerelease: false